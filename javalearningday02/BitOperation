package javalearningday02;

/**
 * 位运算的具体操作
 * @author 小川94
 * @date 2018年1月21日
 */
public class BitOperation {

	public static void main(String[] args) {
		andOperation();
		nonOperation();
		orOperation();
		differentOr();
		withSymbolToLeft();
		withSymbolToRight();
		noSymbolToRight();
	}
	
	/** 
	 * 与（&）运算
	 * 规则：先将要运算的数转为二进制，当相同的位上均为1时结果为1，否则结果为0
	 */
	public static void andOperation() {
		/**
		 * 98的原码: 00000000 00000000 0000000 01100010
		 * 18的原码: 00000000 00000000 0000000 00010010
		 * 与运算后:  00000000 00000000 0000000 00000010
		 * 转换为十进制的数是2
		 */
		int num = 98&18;
		System.out.println("(98&18)的与（&）运算结果:"+num); // num = 2
	}
	
	/** 
	 * 非（~）运算
	 * 规则: 正数的非运算是先取反再计算补码，负数的非运算是先计算补码再取反
	 */
	public static void nonOperation() {
		byte num = ~90;
		/**
		 * 正数非运算：原码 -->取反(1变0,0变1,非运算)-->反码(符号位不变，其余1变0,0变1)--->补码(反码的基础上加1)
		 *      90
		 * 原码: 00000000 00000000 00000000 01011010
		 * 取反: 11111111 11111111 11111111 10100101
		 * 反码: 10000000 00000000 00000000 01011010
		 * 补码: 10000000 00000000 00000000 01011011
		 * 转为十进制数则是-91
		 */
		System.out.println("90的非（~）运算结果:"+num); // num = -91
		
		/**
		 *      10
		 * 原码: 00000000 00000000 00000000 00001010
		 * 取反: 11111111 11111111 11111111 11110101
		 * 反码: 10000000 00000000 00000000 00001010
		 * 补码: 10000000 00000000 00000000 00001011
		 * 转为十进制数是-11
		 */
		System.out.println("10的非（~）运算结果:"+(~10)); // -11
		
		/**
		 * 负数非运算：原码 --->反码(符号位不变，其余1变0,0变1)--->补码(反码的基础上加1)--->取反(1变0,0变1,非运算)
		 *       -5
		 * 原码: 10000000 00000000 00000000 00000101
		 * 反码: 11111111 11111111 11111111 11111010
		 * 补码: 11111111 11111111 11111111 11111011
		 * 取反: 00000000 00000000 00000000 00000100
		 * 转为十进制为 4 
		 */
		System.out.println("(-5)的非（~）运算结果:"+(~(-5))); // 4
	}
	
	/** 
	 * 或（|）运算
	 * 规则:当两边操作数的位有一边为1时，结果为1，否则为0。
	 */
	public static void orOperation() {
		/**
		 * 23的原码: 00000000 00000000 00000000 00010111
		 * 75的原码: 00000000 00000000 00000000 01001011
		 * 或运算:   00000000 00000000 00000000 01011111
		 * 转换为十进制数是95
		 */
		System.out.println("(23|75)的或（|）运算结果"+(23|75)); // 95
	}
	
	/**
	 * 异或（^）运算
	 * 规则:两边的对应位不同时，取1，否则取0。如果遇到负数，需要用负数的补码进行计算
	 */
	public static void differentOr() {
		/**
		 * 17的原码: 00000000 00000000 00000000 00010001
		 * 29的原码: 00000000 00000000 00000000 00011101
		 * 异或运算:  00000000 00000000 00000000 00001100 
		 * 转为十进制数是12
		 */
		System.out.println("(17^29)的异或（^）运算结果:"+(17^29)); //12
		
		/**
		 * -17的原码: 10000000 00000000 00000000 00010001
		 * -17的反码: 11111111 11111111 11111111 11101110
		 * -17的补码: 11111111 11111111 11111111 11101111
		 *  29的补码: 00000000 00000000 00000000 00011101
		 *  运算结果:  11111111 11111111 11111111 11110010
		 *  对结果反码: 10000000 00000000 00000000 00001101 
		 *  对结果补码: 10000000 00000000 00000000 00001110
		 *  结果转为十进制数是-14
		 */
		System.out.println("(-17^29)的异或（^）运算结果:"+(-17^29)); //-14
	}
	
	/**
	 * 带符号左移（<<）运算
	 * 规则: 符号位不变，左移几位，则在补码(正数的补码、反码与原码一样)的后面补几个0
	 *      也可以简单理解成数学运算，左移几位，就是原数乘以2的几次方
	 */
	public static void withSymbolToLeft() {
		/**
		 * 10的原码: 00000000 00000000 00000000 00001010
		 * 左移四位:  00000000 00000000 00000000 10100000
		 * 转换为十进制数是160
		 * 也可以理解成数学运算中的  10*(2*2*2*2) = 10*16 = 160
		 */
		System.out.println("(10<<4)带符号左移（<<）运算的结果:"+(10<<4)); // 160
		/**
		 * -9的原码: 10000000 00000000 00000000 00001001
		 * -9的反码: 11111111 11111111 11111111 11110110
		 * -9的补码: 11111111 11111111 11111111 11110111
		 * 左移4位:  11111111 11111111 11111111 01110000
		 * 再反码:   10000000 00000000 00000000 10001111
		 * 再补码:   10000000 00000000 00000000 10010000
		 * 转为十进制数是-144
		 * 也可以理解成数学运算中的  (-9)*(2*2*2*2) = (-9)*16 = -144
		 */
		System.out.println("(-9)<<4)带符号左移（<<）运算的结果:"+((-9)<<4)); // -144
	}
	
	/**
	 * 带符号右移（>>）运算
	 * 规则: 正数右移时，右移几位，在补码的左边加几个0，右边的被自动挤掉;
	 *      负数右移时，右移几位，在补码的左边加几个1，右边的被自动挤掉
	 */
	public static void withSymbolToRight() {
		/**
		 * 20的原码: 00000000 00000000 00000000 00010100
		 * 右移4位:  00000000 00000000 00000000 00000001
		 * 转为十进制数是1
		 */
		System.out.println("(20>>4)带符号右移（>>）运算结果:"+(20>>4));
		/**
		 * -86的原码: 10000000 00000000 00000000 01010110
		 * -86的反码: 11111111 11111111 11111111 10101001
		 * -86的补码: 11111111 11111111 11111111 10101010
		 * 右移四位:   11111111 11111111 11111111 11111010
		 * 再计算反码:  10000000 00000000 00000000 00000101
		 * 再计算补码:  10000000 00000000 00000000 00000110
		 * 转为十进制数是-6
		 */
		System.out.println("(-86)>>4带符号右移（>>）运算结果:"+((-86)>>4)); // -6
	}
	
	/**
	 * 无符号右移（>>>）运算
	 * 规则: 无论正数还是负数，右移几位，则在其补码左边加上几个0
	 */
	public static void noSymbolToRight() {
		/**
		 * 50的原码: 00000000 00000000 00000000 00110010
		 * 右移4位:  00000000 00000000 00000000 00000011
		 * 转为十进制数是3
		 */
		System.out.println("(50>>>4)的无符号右移（>>>）运算结果:"+(50>>>4)); // 3
		/**
		 * -28的原码: 10000000 00000000 00000000 00011100
		 * -28的反码: 11111111 11111111 11111111 11100011
		 * -28的补码: 11111111 11111111 11111111 11100100
		 * 右移四位:   00001111 11111111 11111111 11111110
		 * 再转为十进制数是  0+0+0+0+134217728+67108864+33554432+16777216
		 * 			   +8388608+4194304+2097152+1048576+524288+262144+131072+65536
		 *             +32768+16384+8192+4096+2048+1024+512+256
		 *             +128+64+32+16+8+4+2+0 = 268435454
		 */
		System.out.println("(-28)>>>4的无符号右移（>>>）运算结果:"+((-28)>>>4)); // 268435454
	}
}
